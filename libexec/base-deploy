#!/usr/bin/env bash

#  Copyright (C) 2019-2021 Maker Ecosystem Growth Holdings, INC.

#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU Affero General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.

#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU Affero General Public License for more details.

#  You should have received a copy of the GNU Affero General Public License
#  along with this program.  If not, see <https://www.gnu.org/licenses/>.

# shellcheck source=lib/common.sh
. "$LIB_DIR/common.sh"

# sethSend "$(eval echo "\$VAL_${token}")" 'setBar(uint256)' "$(seth --to-uint256 3)"
# contract=$(dappCreate ds-value DSValue)
# eval "export VAL_${token}=${contract}"
# logAddr "VAL_${token}" "$(eval "echo ${contract}")"

    echo "$BIN_DIR/contracts/$lib/out"
    echo "$ETH_NONCE"

# Deploy  the oracle module and medianizer contract

tokens=$(jq -r ".tokens | keys_unsorted[]" "$CONFIG_FILE")

for token in $tokens; do
    pipAddr=$(jq -r ".tokens.${token} | .import.pip | values" "$CONFIG_FILE")
    if [[ "$pipAddr" == "" ]]; then
        type=$(jq -r ".tokens.${token} | .pipDeploy | .type | values" "$CONFIG_FILE")
        # Deploy Medianizer as Feed
        if [[ "$type" == "median" ]]; then
            contract=$(dappCreate testchain-medians "Median${token}USD")
            eval "export VAL_${token}=${contract}"
            logAddr "VAL_${token}" "$(eval "echo ${contract}")"
            signers=$(jq -r ".tokens.${token} | .pipDeploy | .signers | .[]" "$CONFIG_FILE")
            # Approve oracle price feed providers
            allsigners=()
            for signer in $signers; do
                allsigners+=("${signer}")
            done
            sethSend "$(eval echo "\$VAL_${token}")" 'lift(address[] memory)' "[$(join "${allsigners[@]}")]"
            # Set quorum for Medianizer
            sethSend "$(eval echo "\$VAL_${token}")" 'setBar(uint256)' "$(seth --to-uint256 3)"
        fi
        # Deploy DSValue as Feed
        if [[ "${type}" == "value" ]]; then
            contract=$(dappCreate ds-value DSValue)
            eval "export VAL_${token}=${contract}"
        fi
    else
        eval "export VAL_${token}=${pipAddr}"
        #copy osm
        #copy testchain-medians
        logAddr "VAL_${token}" "$pipAddr"
    fi
    eval "export PIP_${token}=\$VAL_${token}"
done

# Deploy Multicall
MULTICALL=$(dappCreate multicall Multicall)

# Deploy ProxyRegistry
PROXY_REGISTRY=$(jq -r ".import.proxyRegistry | values" "$CONFIG_FILE")
if [[ -z "$PROXY_REGISTRY" ]]; then
    PROXY_FACTORY=$(dappCreate ds-proxy DSProxyFactory)
    PROXY_REGISTRY=$(dappCreate geb-proxy-registry GebProxyRegistry "$PROXY_FACTORY")
else
    PROXY_FACTORY=$(seth storage "$PROXY_REGISTRY" 1)
    PROXY_FACTORY=0x${PROXY_FACTORY:26:66}
    copy ds-proxy
    copy geb-proxy-registry
fi

# Get a proxy for the deployer address (create if didn't previously exist)
PROXY_DEPLOYER=$(seth call "$PROXY_REGISTRY" 'proxies(address)(address)' "$ETH_FROM")
if [[ "$PROXY_DEPLOYER" == "0x0000000000000000000000000000000000000000" ]]; then
    sethSend "$PROXY_REGISTRY" 'build()'
    PROXY_DEPLOYER="$(seth call "$PROXY_REGISTRY" 'proxies(address)(address)' "$ETH_FROM")"
fi


WETH="$(dappCreate geb-deploy WETH9_)" #"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2" # kovan - "0xd0a1e359811322d97991e03f863a0c30c2cf029c"
sethSend "$WETH" --value 500000000000000000

# create multisig
GEB_MULTISIG=$(jq -r ".import.multisig | values" "$CONFIG_FILE")
if [[ -z "$GEB_PROT" ]]; then
    GEB_MULTISIG="$(dappCreate geb-basic-multisig MultiSigWallet "[$ETH_FROM]" "1" )"
else
    export GEB_MULTISIG
fi
GEB_MULTISIG_PROXY="$(sethSend "$PROXY_FACTORY" "build(address)" "$GEB_MULTISIG")"

# Deploy Fabs
"$LIBEXEC_DIR/H20-core/deploy-fab"
# shellcheck source=/dev/null
. "$OUT_DIR/load-fabs-addr-temp"
rm "$OUT_DIR/load-fabs-addr-temp"


GEB_PROT=$(jq -r ".import.gov | values" "$CONFIG_FILE")
if [[ -z "$GEB_PROT" ]]; then
    # It means the GOV token will be created now in the next deployment script call, then we can send funds to the Faucet and set permissions to FLOP
    newGovToken=true
else
    newGovToken=false
    export GEB_PROT
fi

# If no Governance token is defined, create one
if [ -z "$GEB_PROT" ]
then
    GEB_PROT="$(dappCreate ds-token DSToken '"FLX"' '"FLX"')"
    #GEB_GOV=$(dappCreate ds-token DSToken '"AQA"')
fi

# Mint Gov Token, send to the Faucet and set permissions if a new token
if [[ "$newGovToken" == true ]]; then
    sethSend "$GEB_PROT" 'mint(address,uint256)' "$ETH_FROM" "$(seth --to-uint256 "$(seth --to-wei 1000000 ETH)")"
    # sethSend "$FAUCET" 'gulp(address)' "$MCD_GOV"

    # # Use custom authority for the new GOV token
    # GOV_GUARD=$(dappCreate mkr-authority MkrAuthority)

    # # Set GOV_GUARD as authority of MCD_GOV
    # sethSend "$GEB_GOV" 'setAuthority(address)' "$GOV_GUARD"

    # # Set ownership to MCD_PAUSE_PROXY
    # sethSend "$GEB_GOV" 'setOwner(address)' "$MCD_PAUSE_PROXY"

    # # Allow Flop to mint Gov token
    # sethSend "$GOV_GUARD" 'rely(address)' "$MCD_FLOP"

    # # Set root to MCD_PAUSE_PROXY
    # sethSend "$GOV_GUARD" 'setRoot(address)' "$MCD_PAUSE_PROXY"
fi

# ================== Peripherials ===========================

GEB_POLLING_EMITTER="$(dappCreate geb-polling-emitter GebPollingEmitter)"
GEB_GOV_ACTIONS="$(dappCreate geb-deploy GovActions)"
GEB_GOV_ACTIONS="$(dappCreate geb-pit TokenBurner)"



# ================== Core ===========================


sethSend "$GEB_PROT" 'mint(uint256)' "100000000000000000000"

GEB_DEPLOY=$(dappCreate geb-deploy GebDeploy)

GEB_AUTH="$(dappCreate ds-roles DSRoles)"
sethSend "$GEB_AUTH" 'setRootUser(address, bool)' "$GEB_DEPLOY" true

sethSend "$GEB_DEPLOY" "setFirstFactoryBatch(address,address,address,address,address,address,address)" "$SAFEENGINE_FAB" "$TAXCOLLECTOR_FAB" "$ACCOUNTINGENGINE_FAB" "$LIQUIDATIONENGINE_FAB" "$COIN_FAB" "$COINJOIN_FAB" "$COINSAVINGSACCOUNT_FAB"
sethSend "$GEB_DEPLOY" "setSecondFactoryBatch(address,address,address,address,address,address,address,address)" "$RECYCLINGSURPLUSAUCTIONHOUSE_FAB" "$BURNINGSURPLUSAUCTIONHOUSE_FAB" "$DEBTAUCTIONHOUSE_FAB" "$ENGLISHCOLLATERALAUCTIONHOUSE_FAB" "$INCREASINGDISCOUNTCOLLATERALAUCTIONHOUSE_FAB" "$ORACLERELAYER_FAB" "$GLOBALSETTLEMENT_FAB" "$ESM_FAB"
sethSend "$GEB_DEPLOY" "setThirdFactoryBatch(address,address,address)" "$PAUSE_FAB" "$PROTESTPAUSE_FAB" "$STABILITYFEETREASURY_FAB"

sethSend "$GEB_DEPLOY" 'deploySAFEEngine()'
sethSend "$GEB_DEPLOY" 'deployCoin(string, string, uint256)' '"Rai Reflex Index"' '"RAI"' "99"
sethSend "$GEB_DEPLOY" 'deployTaxation()'
sethSend "$GEB_DEPLOY" 'deployAuctions(address, address, bytes32)' "$GEB_PROT" "$ETH_FROM" "$(seth --to-bytes32 "$(seth --from-ascii "recycling")")"
sethSend "$GEB_DEPLOY" 'deployAccountingEngine()'
sethSend "$GEB_DEPLOY" 'deployStabilityFeeTreasury()'
sethSend "$GEB_DEPLOY" 'deployLiquidator()'
sethSend "$GEB_DEPLOY" 'deployShutdown(address, address, address, uint256)' "$GEB_PROT" "0x0000000000000000000000000000000000000000" "0x0000000000000000000000000000000000000000" "10"

sethSend "$GEB_DEPLOY" 'deployPause(uint256, address)' "0" "$GEB_AUTH"

eval "export VAL_DEPLOY=${contract}"



#sethSend "$(eval echo "\$VAL_DEPLOY")" 'deploySAFEEngine()' ""

GEB_SAFE_ENGINE="$(seth call "$GEB_DEPLOY" "safeEngine()(address)")"
GEB_TAX_COLLECTOR="$(seth call "$GEB_DEPLOY" "taxCollector()(address)")"
GEB_ACCOUNTING_ENGINE="$(seth call "$GEB_DEPLOY" "accountingEngine()(address)")"
GEB_LIQUIDATION_ENGINE="$(seth call "$GEB_DEPLOY" "liquidationEngine()(address)")"
GEB_STABILITY_FEE_TREASURY="$(seth call "$GEB_DEPLOY" "stabilityFeeTreasury()(address)")"
GEB_COIN="$(seth call "$GEB_DEPLOY" "coin()(address)")"
GEB_COIN_JOIN="$(seth call "$GEB_DEPLOY" "coinJoin()(address)")"
GEB_RECYCLING_SURPLUS_AUCTION_HOUSE="$(seth call "$GEB_DEPLOY" "recyclingSurplusAuctionHouse()(address)")"
GEB_BURNING_SURPLUS_AUCTION_HOUSE="$(seth call "$GEB_DEPLOY" "burningSurplusAuctionHouse()(address)")"
GEB_DEBT_AUCTION_HOUSE="$(seth call "$GEB_DEPLOY" "debtAuctionHouse()(address)")"
GEB_ORACLE_RELAYER="$(seth call "$GEB_DEPLOY" "oracleRelayer()(address)")"
GEB_COIN_SAVINGS_ACCOUNT="$(seth call "$GEB_DEPLOY" "coinSavingsAccount()(address)")"
GEB_GLOBAL_SETTLEMENT="$(seth call "$GEB_DEPLOY" "globalSettlement()(address)")"
GEB_ESM="$(seth call "$GEB_DEPLOY" "esm()(address)")"
GEB_PAUSE="$(seth call "$GEB_DEPLOY" "pause()(address)")"
GEB_PROTEST_PAUSE="$(seth call "$GEB_DEPLOY" "protestPause()(address)")"


sethSend "$GEB_AUTH" 'setRootUser(address, bool)' "$GEB_PAUSE" true
sethSend "$GEB_DEPLOY" 'giveControl(address)' "$GEB_PAUSE"



WETH_JOIN="$(dappCreate geb-deploy CollateralJoin1 0x0000000000000000000000000000000000000000 "$(seth --to-bytes32 "$(seth --from-ascii "ETH")")" $WETH)"


sethSend "$GEB_DEPLOY" 'deployCollateral(bytes32, bytes32, address, address, address)' "$(seth --to-bytes32 "$(seth --from-ascii "ENGLISH")")" "$(seth --to-bytes32 "$(seth --from-ascii "ETH")")" "$WETH_JOIN" "$WETH" "0x0000000000000000000000000000000000000000"
sethSend "$GEB_DEPLOY" 'addAuthToCollateralAuctionHouse(bytes32, address)' "$(seth --to-bytes32 "$(seth --from-ascii "ETH")")" "$GEB_PAUSE"

echo "$GEB_SAFE_ENGINE"
echo "$WETH"
echo GEB_SAFE_ENGINE
# Generate addresses.json file
# shellcheck disable=SC2153
cat > "$OUT_DIR"/addresses.json <<EOF
{
    "GEB_PROT": "$(seth --to-checksum-address "$GEB_PROT")",
    "ETH": "$(seth --to-checksum-address "$WETH")",
    "GEB_SAFE_ENGINE": "$(seth --to-checksum-address "$GEB_SAFE_ENGINE")",
    "GEB_TAX_COLLECTOR": "$(seth --to-checksum-address "$GEB_TAX_COLLECTOR")",
    "GEB_ACCOUNTING_ENGINE": "$(seth --to-checksum-address "$GEB_ACCOUNTING_ENGINE")",
    "GEB_LIQUIDATION_ENGINE": "$(seth --to-checksum-address "$GEB_LIQUIDATION_ENGINE")",
    "GEB_STABILITY_FEE_TREASURY": "$(seth --to-checksum-address "$GEB_STABILITY_FEE_TREASURY")",
    "GEB_COIN": "$(seth --to-checksum-address "$GEB_COIN")",
    "GEB_COIN_JOIN": "$(seth --to-checksum-address "$GEB_COIN_JOIN")",
    "GEB_DEBT_AUCTION_HOUSE": "$(seth --to-checksum-address "$GEB_DEBT_AUCTION_HOUSE")",
    "GEB_ORACLE_RELAYER": "$(seth --to-checksum-address "$GEB_ORACLE_RELAYER")",
    "GEB_GLOBAL_SETTLEMENT": "$(seth --to-checksum-address "$GEB_GLOBAL_SETTLEMENT")",
    "GEB_ESM": "$(seth --to-checksum-address "$GEB_ESM")",
    "GEB_PAUSE": "$(seth --to-checksum-address "$GEB_PAUSE")",
    "WETH_JOIN": "$(seth --to-checksum-address "$WETH_JOIN")",
    "PROXY_REGISTRY": "$(seth --to-checksum-address "$PROXY_REGISTRY")",
    "PROXY_FACTORY": "$(seth --to-checksum-address "$PROXY_FACTORY")",
    "PROXY_DEPLOYER": "$(seth --to-checksum-address "$PROXY_DEPLOYER")",
    "MULTICALL": "$(seth --to-checksum-address "$MULTICALL")",
    "GEB_DEPLOY": "$(seth --to-checksum-address "$GEB_DEPLOY")",
    "GEB_MULTISIG": "$(seth --to-checksum-address "$GEB_MULTISIG")",
    "GEB_MULTISIG_PROXY": "$(seth --to-checksum-address "$GEB_MULTISIG_PROXY")",
    "GEB_POLLING_EMITTER": "$(seth --to-checksum-address "$GEB_POLLING_EMITTER")",
    "GEB_GOV_ACTIONS": "$(seth --to-checksum-address "$GEB_GOV_ACTIONS")",



    "GEB_PROTEST_PAUSE": "$(seth --to-checksum-address "$GEB_PROTEST_PAUSE")",
    "GEB_COIN_SAVINGS_ACCOUNT": "$(seth --to-checksum-address "$GEB_COIN_SAVINGS_ACCOUNT")",
    "GEB_BURNING_SURPLUS_AUCTION_HOUSE": "$(seth --to-checksum-address "$GEB_BURNING_SURPLUS_AUCTION_HOUSE")",
    "GEB_RECYCLING_SURPLUS_AUCTION_HOUSE": "$(seth --to-checksum-address "$GEB_RECYCLING_SURPLUS_AUCTION_HOUSE")",
}
EOF

        # // Set SAFEEngine Params
        # this.modifyParameters(address(safeEngine), bytes32("globalDebtCeiling"), uint(10000 * 10 ** 45));
        # this.modifyParameters(address(safeEngine), bytes32("ETH"), bytes32("debtCeiling"), uint(10000 * 10 ** 45));

        # orclETH.updateResult(300 * 10 ** 18); // Price 300 COIN = 1 ETH (precision 18)
        # orclCOIN.updateResult(1 * 10 ** 18);  // Price 1 COIN = 1 USD

        # priceSourceETH.updateResult(300 * 10 ** 18); // Price 300 COIN = 1 ETH (precision 18)
        # priceSourceCOIN.updateResult(1 * 10 ** 18);  // Price 1 COIN = 1 USD

        # (ethEnglishCollateralAuctionHouse, ethIncreasingDiscountCollateralAuctionHouse,) = gebDeploy.collateralTypes("ETH");
        # this.modifyParameters(address(oracleRelayer), "ETH", "safetyCRatio", uint(1500000000 ether));
        # this.modifyParameters(address(oracleRelayer), "ETH", "liquidationCRatio", uint(1500000000 ether));

        # oracleRelayer.updateCollateralPrice("ETH");
        # (,,uint safetyPrice,,,uint liquidationPrice) = safeEngine.collateralTypes("ETH");

        # DSGuard(address(prot.authority())).permit(address(debtAuctionHouse), address(prot), bytes4(keccak256("mint(address,uint256)")));
        # DSGuard(address(prot.authority())).permit(address(recyclingSurplusAuctionHouse), address(prot), bytes4(keccak256("burn(address,uint256)")));


# authority.setRootUser(pauseProxy, true);
# gebDeploy.giveControl(pauseProxy);

# weth = new WETH9_();
# ethJoin = new CollateralJoin1(address(safeEngine), "ETH", address(weth));
# gebDeploy.deployCollateral(auctionType, "ETH", address(ethJoin), address(orclETH), address(0));
# gebDeploy.addAuthToCollateralAuctionHouse("ETH", pauseProxy);